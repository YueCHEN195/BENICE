# js基础

## 1.js数据类型

基本数据类型：Number String Boolean Null Undefined Symbol (ES6)
undefined: 数据越界，变量定义了但是没有赋值，访问对象下没有的属性，获取一个没有返回值的函数的返回值
null: 访问一个不存在的值
引用数据类型：Array Object

## 2.什么是类

具有相同的属性和方法的对象的集合

## 3.堆内存和栈内存

js中数据类型有两种 一种是基本类型 另一种是引用类型。区别在于基本类型占有的内存大小是固定的，比如Boolean  String Number undefined null,这些值就存在栈内存中，而引用类型的占有的内存大小不固定，所以引用类型的值也就存放在堆内存中，比如Object Array 这些都是在堆内存中的；我们访问引用类型的时候，我们先是通过变量名去栈内存中拿到该值在堆内存中的地址，然后通过这个地址再去堆内存访问其值

栈内存中储存的是占用空间大小固定的基本数据类型，以及指向引用类型的指针（保存引用类型在堆内存中的位置）

关于const ：const实际上并不是保证一个变量的值不变，而是保证变量指向的内存地址不能改变，实际上基本数据类型的原始值其本身就是不能改变的，当我们修改它的时候
实际上是把它的变量名指向了一个新的地址而已，那么就很好理解const const禁止我们把变量名指向一个新的地址，所以我们就无法修改通过const定义的变量的值了。但是

用const定义一个对象的时候，我们可以修改这个对象的内容，比如我们定义一个对象person，person变量名在存放在栈内存中的一个地址，指向堆内存中存放的对象的值，这个值并不受const的约束，所以我们可以改变它。

## 4.原型式继承

自有属性（方法）：这个对象本身就有的属性。
继承属性（方法）：在对象的原型对象中定义的属性和方法

每一个对象都有一个隐式原型也就是，这个隐式原型指向的是构造它的构造函数的原型对象（prototype），当我们调用该对象的属性或者方法的时候，要是这个对象
自身并没有这个方法，就回去他的隐式原型指向的对象（也就是它的构造函数的原型对象上查找）上取查找，如果还没有，就会去它的构造函数的隐式原型指向的对象上去
查找，这就是通过原型链实现的继承。

## 5.环境和作用域

作用域就是代码的执行环境，全局执行环境就是全局作用域，全局作用域和私有作用域都是栈内存。每个执行环境都有一个与之想关联的对象，环境中定义的变量和函数就是这个对象的属性和方法。在浏览器运行环境中，全局变量和函数就是定义在window对象上的，在node中这是定义在global上的。

## 6.闭包

闭包：当一个函数的返回值是一个定义在其内部的函数，且这个定义在其内部的函数调用了定义在父函数内部的变量，且这个返回来的函数在外部被执行了，这就产生了一个闭包。

## 7.JS中的垃圾回收机制

垃圾回收机制是用来管理代码执行中使用的内存的，垃圾回收器会定期的管理不再继续使用的变量，然后将内存释放出去。这个过程不是实时的，是周期性进行的。
两种常见的垃圾回收策略

标记清除：对于脱离作用域的变量进行回收，当进入作用域的时候，进行标记，离开作用域的时候，标记并回收这些垃圾。
当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。

引用计数：跟踪每个值被引用的次数，被引用一次则+1，当这个引用计数为0的时候，被视为回收对象，就会被回收。循环引用的时候会导致死锁，导致内存泄露。

常见内存泄露的原因：

1.全局变量引起的内存泄露
2.闭包引起的内存泄露：慎用闭包
3.dom清空或删除时，事件未清除导致的内存泄漏
4.循环引用带来的内存泄露

GC会导致停止响应

## 8.call apply bind

## 9.事件模型

DOM事件标准定义了两种事件流，这两种事件流有着显著的不同并且可能对你的应用有着相当大的影响。这两种事件流分别是捕获和冒泡。
事件捕获阶段，处于目标阶段，事件冒泡阶段,你可以在事件捕获阶段处理事件也可以在事件冒泡阶段处理事件。

冒泡：事件的触发顺序是由内层元素向外层，事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。
事件的对象有一个 stopPropagation()
`document.getElementById('div').addEventListener('click',(event){alert('clicked'); event.stopPropagation()})`
捕获：事件的触发顺序是由外层元素向内层元素，事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。

事件委托：当我们想要给多个子元素都绑定一个事件的时候，可以把这个事件绑定在父元素身上，通过冒泡的方式来触发该事件。

## 10.对象深克隆

递归

``` JavaScript
function clone(obj){
  var res = {}
  if(typeof obj[key] == 'object' || 'array'){
    res[key] = clone(obj[key])
  }else{
    res[key] = obj[key]
  }
  return res
}
```

``` JavaScript
var clone = JSON.parse(JSON.stringify(obj))
```

## 11.sessionStorage localStorage cookie session

若不设置过期时间，cookie会在浏览器会话关闭之后就会消失，称为会话cookie，这种cookie储存在内存中，如果设置了过期时间，这个cookie会储存在硬盘中。
session是储存在服务端的用来识别用户的储备空间，创建session成功之后，服务端会返回一个session ID，这个session ID储备在cookie中，以后客户端访问服务器的时候带着这个session ID来
请求，服务端就知道是谁了。

cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生，Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽。

作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的

sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的

共同点：都是保存在浏览器端、且同源的
区别：
1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭

4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的

5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6、web Storage的api接口使用更方便

## 12.有哪些新特性

let const promise 箭头函数 解构赋值 class set map weakset weakmap proxy 一些数组的新方法 模板字符串

## 12 map和weakmap set和weakset

set是储存数据的集合，无序且唯一。方法：add，delete，has，clear，属性：size 不重复的值的集合

weakset是专门用来存储对象的，且存储对象是弱引用的，就是说存储在weakset中并不会增加变量的引用次数，weakset不能被遍历

map是用来保存键值对的。跟对象不同的是map的键可以是任意类型，对象的键只能是字符串/或者symbols，map可以直接进行迭代，object的迭代需要先获取它的键数组。

实现了iterator接口的，且每个成员都是一个双元素的数组数据结构都可以当作map构造函数的参数。map的键是跟栈内存地址绑定的

set(key,value) get(key) has(key) delete(key) 在weakmap中键是弱引用对象，只接受对象作为键